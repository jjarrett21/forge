import fs from "fs-extra";
import path from "path";
import type { Blueprint } from "../../src/compose.js";

export const blueprint: Blueprint = {
  scripts: {
    "dev:api": "cd backend && cargo watch -x run",
    "build:api": "cd backend && cargo build --release",
    "start:api": "cd backend && cargo run --release",
  },
  async setup(target: string) {
    const backendDir = path.join(target, "backend");
    await fs.ensureDir(backendDir);
    await fs.ensureDir(path.join(backendDir, "src"));
    await fs.ensureDir(path.join(backendDir, "src", "handlers"));
    await fs.ensureDir(path.join(backendDir, "src", "models"));

    // Create Cargo.toml
    await fs.writeFile(
      path.join(backendDir, "Cargo.toml"),
      `[package]
name = "backend"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4.4"
actix-cors = "0.6"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1", features = ["full"] }
sqlx = { version = "0.7", features = ["runtime-tokio-native-tls", "postgres"] }
dotenv = "0.15"

[dev-dependencies]
cargo-watch = "8.1"
`
    );

    // Create main.rs
    await fs.writeFile(
      path.join(backendDir, "src", "main.rs"),
      `use actix_web::{web, App, HttpServer, Responder, HttpResponse};
use actix_cors::Cors;
use serde::{Deserialize, Serialize};
use std::env;

#[derive(Serialize, Deserialize)]
struct HealthResponse {
    status: String,
}

async fn health() -> impl Responder {
    HttpResponse::Ok().json(HealthResponse {
        status: "ok".to_string(),
    })
}

async fn get_users() -> impl Responder {
    // Example: Return empty array for now
    // In a real app, you would query the database here
    HttpResponse::Ok().json::<Vec<serde_json::Value>>(vec![])
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    dotenv::dotenv().ok();
    
    let port = env::var("PORT")
        .unwrap_or_else(|_| "8080".to_string())
        .parse::<u16>()
        .expect("PORT must be a valid number");

    println!("Server starting on port {}", port);

    HttpServer::new(|| {
        let cors = Cors::default()
            .allow_any_origin()
            .allow_any_method()
            .allow_any_header()
            .max_age(3600);

        App::new()
            .wrap(cors)
            .route("/health", web::get().to(health))
            .route("/api/users", web::get().to(get_users))
    })
    .bind(("0.0.0.0", port))?
    .run()
    .await
}
`
    );

    // Create .env.example
    await fs.writeFile(
      path.join(backendDir, ".env.example"),
      `DATABASE_URL=postgresql://postgres:postgres@localhost:5432/mydb
PORT=8080
`
    );

    // Create README.md
    await fs.writeFile(
      path.join(backendDir, "README.md"),
      `# Rust Backend

RESTful API built with Rust, Actix Web, and PostgreSQL.

## Prerequisites

- Rust (install from https://rustup.rs/)
- PostgreSQL database
- Cargo (comes with Rust)

## Setup

1. Install dependencies:
\`\`\`bash
cd backend
cargo build
\`\`\`

2. Set up your database:
\`\`\`bash
# Copy .env.example to .env and update DATABASE_URL
cp .env.example .env

# Create your database
createdb mydb
\`\`\`

3. Run the server:
\`\`\`bash
cargo run
\`\`\`

For development with auto-reload:
\`\`\`bash
cargo install cargo-watch
cargo watch -x run
\`\`\`

For production:
\`\`\`bash
cargo build --release
./target/release/backend
\`\`\`

## Environment Variables

- \`DATABASE_URL\` - PostgreSQL connection string
- \`PORT\` - Server port (default: 8080)

## API Endpoints

- \`GET /health\` - Health check endpoint
- \`GET /api/users\` - Get list of users

## Project Structure

- \`src/main.rs\` - Main application entry point
- \`src/handlers/\` - Request handlers
- \`src/models/\` - Data models
- \`Cargo.toml\` - Rust dependencies and project configuration
`
    );

    // Create .gitignore
    await fs.writeFile(
      path.join(backendDir, ".gitignore"),
      `# Generated by Cargo
/target/
**/*.rs.bk
*.pdb
Cargo.lock

# Environment files
.env
`
    );
  },
};

